#!/usr/bin/gawk -f

# gcp-log-postprocess: a postprocessor that takes gcloud logging read output
# in CSV format and transforms it into human readble TSV values suitable for
# Unix shell utilities and graphing using the Google Chart API & Google Sheets

# Author: Eido Inoue <eido_inoue@menu.inc>
# Last revsion: 2020-02-07, version 1.0.0
# Copyright © 2021: menu, Inc.

# ### LICENSE & WARRANTY
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

function usage() {
    print "Global Option Variables:" > "/dev/stderr"
    print "   -v nohead=BOOLEAN       Do not print a header on line 1 if true" > "/dev/stderr"
    print "   -v show=id              Show the id parameter for fast and slow methods" > "/dev/stderr"
    print "   -v show=when            Show local timestamps for the fast and slow methods" > "/dev/stderr"
    print "   -v histogram=calls      Show histogram for api calls over time" > "/dev/stderr"
    print "   -v histogram=STRING     Show histogram for api called 'method'/string over time" > "/dev/stderr"
    print "   -v population=BOOLEAN   Use population standard deviation if true" > "/dev/stderr"
    print "   -v resolution=minutes   Set time difference resolution to tens of minutes" > "/dev/stderr"
    print > "/dev/stderr"
    print "Input: RFC 4180 compliant CSV file with CRLF newlines generated by 'gcloud logging read'" > "/dev/stderr"
    print "   with at least the following fields:" > "/dev/stderr"
    print "      latency" > "/dev/stderr"
    print "      timestamp" > "/dev/stderr"
    print "      request_url" > "/dev/stderr"
    print > "/dev/stderr"
    print "Output: TSV (tab separated values) file with LF newlines with a histogram or call summary" > "/dev/stderr"
    print "      x̄ = sample mean (average)" > "/dev/stderr"
    print "      s = sample standard deviation" > "/dev/stderr"
    print "      μ = population mean (average)" > "/dev/stderr"
    print "      σ = population standard deviation" > "/dev/stderr"
    print > "/dev/stderr"
    print "Example Google Cloud SDK command:" > "/dev/stderr"
    print "   gcloud logging read 'httpRequest.userAgent:\"menu/\" AND (" > "/dev/stderr"
    print "      (timestamp >= \\\"2021-02-01T11:00:00+09\\\"" > "/dev/stderr"
    print "         AND timestamp < \\\"2021-02-01T14:00:00+09\\\") OR" > "/dev/stderr"
    print "      (timestamp >= \\\"2021-02-01T17:00:00+09\\\"" > "/dev/stderr"
    print "          AND timestamp < \\\"2021-02-01T22:00:00+09\\\")" > "/dev/stderr"
    print "   )' --format=\"csv(httpRequest.latency,timestamp,httpRequest.requestUrl)\"" > "/dev/stderr"
}

function getopt() {
    for (i = 1; i < ARGC; i++)
        switch (ARGV[i]) {
        case "--usage":
        case "-u":
            usage()
            nohead = 1; exit
        }
}

BEGIN {
    # This field pattern separator feature requires GNU not POSIX or plain awk
    # for processing RFC 4180 CSV escape patterns (quoted fields and embedded commas)
    FPAT = "(\"[^\"]*\")|([^,]*)"   # changing of first + to * allows CSV fields to be empty
    FS = ","
    RS = "\r\n"                     # RFC 4180 CSV files are supposed to have CRLF NLs regardless of platform
    ISO8601 = "%Y%m%dT%H%M"    # ISO 8601 compatible, localtime not UTC time
    MEAN = population ? "μ" : "x̄" 
    SD = population ? "σ" : "s" 
    getopt()
}

NR == 1 {
    for (i = 1; i <= NF; i++)       # figure out the order of the fields from the CSV header line
        field[$i] = i
}

$3 ~ /[?&]method=[[:alpha:]]/ {
    latency = strtonum($field["latency"])                               # will ignore seconds unit "s" suffix from float
    utc = match($field["timestamp"], /.*Z$/)                            # utc is true if Zulu time (GMT+0000, no DST)
    datespec = gensub(/[-:TZ]/, " ", "g", $field["timestamp"])          # convert to "YYYY MM DD HH MM SS"
    sub(/\.[[:digit:]]+ *$/, "", datespec)                              # remove fractions of a second       
    timestamp = mktime(datespec, utc)                                   # convert to POSIX 1970 epoch + seconds

    switch (resolution) {
    case "minutes":                                                     # bucket resolution is per 10 minutes
        re = @/^(.* [[:digit:]])[[:digit:]] [[:digit:].]{2,} *$/
        replacement = "\\10 00"
        break
    default:                                                            # bucket resolution is per hour
        re = @/^(.*) [[:digit:]]{2} [[:digit:].]{2,} *$/
        replacement = "\\1 00 00"
    }
    tm = mktime(gensub(re, replacement, 1, datespec), utc)

    re = @/^https:.*[?&]method=([[:alpha:]]+).*$/
    method = gensub(re, "\\1", 1, $field["request_url"])                # extract method from "?method=" parameter
    s = match($field["request_url"], /[?&]id=[[:digit:]]+$/)            # extract id from last "&id=" parameter
    id = s ? substr($field["request_url"], s + length("&id=")) : "(null)"     

    x = histogram ? tm : method
    if (!histogram || histogram == "calls" || toupper(histogram) == toupper(method)) {
        if (x in calls) {
            calls[x]++
            sum[x] += latency
            sumsq[x] += latency ^ 2        
            if (latency > max[x]) {
                max[x] = latency
                max_timestamp[x] = timestamp
                max_id[x] = id
            }
            if (latency < min[x]) {
                min[x] = latency
                min_timestamp[x] = timestamp
                min_id[x] = id
            }
        }
        else {
            calls[x] = 1
            sum[x] = latency
            sumsq[x] = latency ^ 2
            max[x] = min[x] = latency
            min_timestamp[x] = max_timestamp[x] = timestamp
            min_id[x] = max_id[x] = id
        }
    }
}

END {    
    if (!nohead) {
        if (histogram) {
            x = histogram == "calls" ? "#" : tolower(histogram)
            switch (show) {
            case "id":
                printf " start(time)\t  end(time)\t     lag.max(id) \t lag.%s(ms)\t lag.%s(ms)\t     lag.min(id) \t  calls(%s)\n", MEAN, SD, x
                break
            case "when":
                printf " start(time)\t  end(time)\tlag.max(time)\t lag.%s(ms)\t lag.%s(ms)\tlag.min(time)\t  calls(%s)\n", MEAN, SD, x
                break
            default:
                printf " start(time)\t  end(time)\tlag.max(ms)\t lag.%s(ms)\t lag.%s(ms)\tlag.min(ms)\t  calls(%s)\n", MEAN, SD, x
            }
        } 
        else switch (show) {
        case "id":
            printf "  calls(#)\t     lag.max(id) \t lag.%s(ms)\t lag.%s(ms)\t     lag.min(id) \trequest_url.method\n", MEAN, SD
            break
        case "when":
            printf "  calls(#)\tlag.max(time)\t lag.%s(ms)\t lag.%s(ms)\tlag.min(time)\trequest_url.method\n", MEAN, SD
            break
        default:
            printf "  calls(#)\tlag.max(ms)\t lag.%s(ms)\t lag.%s(ms)\tlag.min(ms)\trequest_url.method\n", MEAN, SD
        } 
    }
    for (x in calls) {
        n = calls[x]
        high = max[x] * 1000
        low = min[x] * 1000
        avg = sum[x] / n * 1000
        sigma = (n - (population ? 0 : 1)) <= 0 ? 0 : sqrt((sumsq[x] - sum[x] ^ 2 / n)/ (n - (population ? 0 : 1))) * 1000;
        slowest = strftime(ISO8601, max_timestamp[x])
        fastest = strftime(ISO8601, min_timestamp[x])

        if (histogram) {
            start = strftime(ISO8601, x)
            offset = 60 * (resolution == "minutes" ? 10 : 60) - 1   # range is either 10 or 60 minutes
            stop = strftime(ISO8601, x + offset)
            switch (show) {
            case "id":
                printf "%s\t%s\t%16s\t%10.3f\t%10.3f\t%16s\t%10i\n", start, stop, max_id[x], avg, sigma, min_id[x], n
                break
            case "when":
                printf "%13s\t%13s\t%13s\t%10.3f\t%10.3f\t%13s\t%10i\n", start, stop, slowest, avg, sigma, fastest, n
                break
            default:
                printf "%s\t%s\t %10.3f\t%10.3f\t%10.3f\t %10.3f\t%10i\n", start, stop, high, avg, sigma, low, n
            }
        }
        else switch (show) {
        case "id":
            printf "%10i\t%16s\t%10.3f\t%10.3f\t%16s\t%s\n", n, max_id[x], avg, sigma, min_id[x], x
            break
        case "when":
            printf "%10i\t%13s\t%10.3f\t%10.3f\t%13s\t%s\n", n, slowest, avg, sigma, fastest, x
            break
        default:
            printf "%10i\t %10.3f\t%10.3f\t%10.3f\t %10.3f\t%s\n", n, high, avg, sigma, low, x
        }
    }
}
